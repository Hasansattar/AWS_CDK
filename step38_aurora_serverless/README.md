# AMAZON AURORA

Amazon Aurora is a MySQL and PostgreSQL-compatible relational database built for the cloud, that combines the performance and availability of traditional enterprise databases with the simplicity and cost-effectiveness of open source databases. Its up to 5 times faster than standard MySQL databases and 3 times faster than standard PostgreSQL databases. It provides the security, availability, and reliability of commercial databases at 1/10th the cost and is fully managed by Amazon Relational Database Service (RDS).
Amazon Aurora features a distributed, fault-tolerant, self-healing storage system that auto-scales up to 128TB per database instance. It delivers high performance and availability with up to 15 low-latency read replicas, point-in-time recovery, continuous backup to Amazon S3, and replication across three Availability Zones (AZs).

# AMAZON AURORA SERVERLESS

Amazon Aurora Serverless is an on-demand, auto-scaling configuration for Amazon Aurora. It automatically starts up, shuts down, and scales capacity up or down based on your application's needs. It enables you to run your database in the cloud without managing any database capacity. Manually managing database capacity can take up valuable time and can lead to inefficient use of database resources. With Aurora Serverless, you simply create a database endpoint, optionally specify the desired database capacity range, and connect your applications. You pay on a per-second basis for the database capacity you use when the database is active, and migrate between standard and serverless configurations with a few clicks in the Amazon RDS Management Console.

Aurora Serverless v1 is available for both Amazon Aurora with MySQL compatibility and Amazon Aurora with PostgreSQL compatibility. It's easy to get started: choose `Serverless` when creating your Aurora database cluster, optionally specify the desired range of database capacity, and connect your applications.

# Amazon RDS for MySql

MySQL is the world's most popular open source relational database and Amazon RDS makes it easy to set up, operate, and scale MySQL deployments in the cloud. With Amazon RDS, you can deploy scalable MySQL servers in minutes with cost-efficient and resizable hardware capacity.

Amazon RDS for MySQL frees you up to focus on application development by managing time-consuming database administration tasks including backups, software patching, monitoring, scaling and replication.
Amazon RDS supports DB instances running several versions of MySQL.

#### Reference

[What is AWS Aurora](https://aws.amazon.com/rds/aurora/?aurora-whats-new.sort-by=item.additionalFields.postDateTime&aurora-whats-new.sort-order=desc),
[Amazon Aurora Serverless](https://aws.amazon.com/rds/aurora/serverless/)

# DB Cluster

The basic building block of Amazon RDS is the DB instance. A database cluster means more than one database instances working together.

# Amazon VPC

You can run a DB instance on a virtual private cloud (VPC) using the Amazon Virtual Private Cloud (Amazon VPC) service. When you use a VPC, you have control over your virtual networking environment.

# Engine

Amazon Aurora is a MySQL and PostgreSQL-compatible relational database.

# Scaling

Aurora Serverless clusters can specify scaling properties which will be used to automatically scale the database cluster seamlessly based on the workload.

Available Serverless Cluster Props:[ServerlessClusterProps](https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-rds.ServerlessClusterProps.html)

# Starting an instance database

# install & import modules:

`"@aws-cdk/aws-rds"` ,
`"@aws-cdk/aws-secretsmanager"` ,
`"@aws-cdk/aws-iam"` ,
`@aws-cdk/aws-ec2"`.

## Create a VPC

To set up a instance database, define a DatabaseInstance. You must always launch a database in a VPC. Use the vpcSubnets attribute to control whether your instances will be launched privately or publicly:

```javascript
// step #1: create a vpc for RDS instance

const vpc = new ec2.Vpc(this, "myrdsvpc");
```

## Create a Serverless database cluster

```javascript
// step #2: create database cluster

const myServerlessDB = new rds.ServerlessCluster(this, "ServerlessDB", {
  vpc,
  engine: rds.DatabaseClusterEngine.auroraMysql({
    version: rds.AuroraMysqlEngineVersion.VER_5_7_12,
  }),
  scaling: {
    autoPause: cdk.Duration.minutes(10), // default is to pause after 5 minutes of idle time
    minCapacity: rds.AuroraCapacityUnit.ACU_8, // default is 2 Aurora capacity units (ACUs)
    maxCapacity: rds.AuroraCapacityUnit.ACU_32, // default is 16 Aurora capacity units (ACUs)
  },
  deletionProtection: false,
  defaultDatabaseName: "mysqldb",
});
```

# Database Credentials

On creating a Database Instance, AWS will create Databse credentials with:
{username: "admin",
password: "generated by aws",
databaseName: "if not provided by us"
instanceIdentifier: "generated by aws",
resourceArn: "generated by aws",
secretArn: "generated by aws",
InstanceEndpoint: "generated by aws"}

we would require this to access our database from within lambda either through secrets manager or environment variables

# Accessing your database

In order to access your MySQL database locally install MySQL Client on your system or use Online Tool MySQL Workbench using instances' endpoint(aka, host-name), database name and password (in our case provided by AWS ).
In this step we will access our database with Lambda using a client library. For this we will provide permissions to lambda to have full access to RDS. Lambda would also require permission to access VPC, wherein the Database Instance is created.

```javascript
// step #3: give lambda permissions to access RDS and VPC from aws managed policy

const role = new iam.Role(this, "LambdaRole", {
  assumedBy: new iam.ServicePrincipal("lambda.amazonaws.com"),
  managedPolicies: [
    iam.ManagedPolicy.fromAwsManagedPolicyName("AmazonRDSDataFullAccess"),
    iam.ManagedPolicy.fromAwsManagedPolicyName(
      "service-role/AWSLambdaVPCAccessExecutionRole"
    ),
  ],
});

// step #4: create a lambda function with role and vpc to access database providing database endpoint and database credential in environmental variables.
// Lambda can access these through Secrets Manager too but for that lambda would require permission to access secrets manager too.

// clusters secret arn
const secarn = myServerlessDB.secret?.secretArn || "secret-arn";

const hello = new lambda.Function(this, "HelloHandler", {
  runtime: lambda.Runtime.NODEJS_10_X,
  code: lambda.Code.fromAsset("lambda/lambda-p.zip"),
  handler: "index.handler",
  timeout: cdk.Duration.minutes(1),
  vpc,
  role,
  environment: {
    INSTANCE_CREDENTIALS: `${
      SM.Secret.fromSecretAttributes(this, "dbcredentials", {
        secretArn: secarn,
      }).secretValue
    }`,
  },
});

// step #5: create lambda once dbinstance is created as we have to provide credentials
hello.node.addDependency(myServerlessDB);
```

# Connecting

To control who can access the cluster or instance, use the .connections attribute. RDS databases have a default port:3306

```javascript
// step #6: create connection
myServerlessDB.connections.allowFromAnyIpv4(ec2.Port.tcp(3306));
```

.......


[BUILD SERVERLESS APPLICATIONS USING AURORA SERVERLESS, THE DATA API AND CDK VIDEO TUTORIAL](https://www.youtube.com/watch?v=kU8nwAbA8No)

[Step 38 and 39 Video in English on Facebook](https://www.facebook.com/zeeshanhanif/videos/10226116722369437)

[Step 38 and 39 Video in English on YouTube](https://www.youtube.com/watch?v=NC_az7syauM)

[Step 38 and 39 Video in Urdu on Facebook](https://www.facebook.com/zeeshanhanif/videos/10226125216901795)

[Step 38 and 39 Video in Urdu on YouTube](https://www.youtube.com/watch?v=OGS5Qr9TmsM)

